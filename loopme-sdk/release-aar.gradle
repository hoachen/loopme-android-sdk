import com.android.annotations.NonNull
import com.android.manifmerger.ManifestMerger2
import com.android.manifmerger.ManifestMerger2.Invoker
import com.android.manifmerger.ManifestMerger2.MergeType
import com.android.manifmerger.MergingReport
import com.android.manifmerger.PlaceholderEncoder
import com.android.manifmerger.XmlDocument
import com.android.utils.ILogger
import com.google.common.base.Charsets
import com.google.common.io.Files

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:manifest-merger:25.2.0'
    }
}

configurations {
    release
}

dependencies {
    compile configurations.release
}

ext.releaseJars = new ArrayList<String>()
ext.releaseAarDirs = new ArrayList<String>()
ext.releaseRClasses = new ArrayList<String>()

ext.build_dir = buildDir.path.replace(File.separator, '/');

ext.exploded_aar_dir = "$build_dir/intermediates/exploded-aar";
ext.classs_release_dir = "$build_dir/intermediates/classes/release";
ext.bundle_release_dir = "$build_dir/intermediates/bundles/release";
ext.manifest_aaapt_dir = "$build_dir/intermediates/manifests/aapt/release";
ext.generated_rsrc_dir = "$build_dir/generated/source/r/release";

ext.base_r2x_dir = "$build_dir/release-aar/release/";

afterEvaluate {
    def dependencies = new ArrayList(configurations.release.resolvedConfiguration.firstLevelModuleDependencies)
    dependencies.reverseEach {
        def aarPath = "${exploded_aar_dir}/${it.moduleGroup}/${it.moduleName}/${it.moduleVersion}"
        it.moduleArtifacts.each {
            artifact ->
                if (artifact.type == 'aar') {
                    if (!releaseAarDirs.contains(aarPath)) {
                        releaseAarDirs.add(aarPath)
                    }
                } else if (artifact.type == 'jar') {
                    def artifactPath = artifact.file
                    if (!releaseJars.contains(artifactPath))
                        releaseJars.add(artifactPath)
                } else {
                    throw new Exception("Unhandled Artifact of type ${artifact.type}")
                }
        }
    }

    if (dependencies.size() > 0) {
        // Merge Assets
        generateReleaseAssets.dependsOn releaseAssets
        releaseAssets.dependsOn prepareReleaseDependencies

        packageReleaseResources.dependsOn releaseLibraryResources
        releaseLibraryResources.dependsOn prepareReleaseDependencies

        bundleRelease.dependsOn releaseJniLibs
        releaseJniLibs.dependsOn transformNative_libsWithSyncJniLibsForRelease

        bundleRelease.dependsOn releaseManifests
        releaseManifests.dependsOn processReleaseManifest

        releaseLibraryResources.dependsOn releaseProguard
        releaseProguard.dependsOn prepareReleaseDependencies

        compileReleaseJavaWithJavac.dependsOn generateRJava
        generateRJava.dependsOn processReleaseResources

        bundleRelease.dependsOn releaseJavaJars
        releaseJavaJars.dependsOn compileReleaseJavaWithJavac

        if (tasks.findByPath('proguardRelease') != null) {
            proguardRelease.dependsOn releaseJavaJars
        } else if (tasks.findByPath('transformClassesAndResourcesWithProguardForRelease') != null) {
            transformClassesAndResourcesWithProguardForRelease.dependsOn releaseJavaJars
        }
    }
}

task releaseLibraryResources << {
    println "Running RELEASE-AAR Task :releaseLibraryResources"

    def oldInputResourceSet = packageReleaseResources.inputResourceSets
    packageReleaseResources.conventionMapping.map("inputResourceSets") {
        getMergedInputResourceSets(oldInputResourceSet)
    }
}

private List getMergedInputResourceSets(List inputResourceSet) {
    def ResourceSetClass = inputResourceSet.get(0).class

    List newInputResourceSet = new ArrayList(inputResourceSet)

    releaseAarDirs.each { aarPath ->
        try {
            def resname = (aarPath.split(exploded_aar_dir)[1]).replace('/', ':');
            def rs = ResourceSetClass.newInstance([resname, true] as Object[])
            rs.addSource(file("$aarPath/res"))
            newInputResourceSet += rs
        } catch (Exception e) {
            e.printStackTrace();
            throw e;
        }
    }

    return newInputResourceSet
}

task releaseAssets << {
    println "Running RELEASE-AAR Task :releaseAssets"
    releaseAarDirs.each { aarPath ->
        android.sourceSets.main.assets.srcDirs += file("$aarPath/assets")
    }
}

task releaseProguard << {
    println "Running RELEASE-AAR Task :releaseProguard"

    def proguardRelease = file("$bundle_release_dir/proguard.txt")
    releaseAarDirs.each { aarPath ->
        try {
            def proguardLibFile = file("$aarPath/proguard.txt")
            if (proguardLibFile.exists())
                proguardRelease.append(proguardLibFile.text)
        } catch (Exception e) {
            e.printStackTrace();
            throw e;
        }
    }
}


task generateRJava << {
    println "Running RELEASE-AAR Task :generateRJava"
    def libPackageName = new XmlParser().parse(android.sourceSets.main.manifest.srcFile).@package

    releaseAarDirs.each { aarPath ->

        def aarManifest = new XmlParser().parse(file("$aarPath/AndroidManifest.xml"));
        def aarPackageName = aarManifest.@package
        String packagePath = aarPackageName.replace('.', '/')

        def rTxt = file("$aarPath/R.txt")
        def rMap = new ConfigObject()

        if (rTxt.exists()) {
            rTxt.eachLine {
                line ->
                    def (type, subclass, name, value) = line.tokenize(' ')
                    rMap[subclass].putAt(name, type)
            }
        }

        def sb = "package $aarPackageName;" << '\n' << '\n'
        sb << 'public final class R {' << '\n'

        rMap.each {
            subclass, values ->
                sb << "  public static final class $subclass {" << '\n'
                values.each {
                    name, type ->
                        sb << "    public static $type $name = ${libPackageName}.R.${subclass}.${name};" << '\n'
                }
                sb << "    }" << '\n'
        }

        sb << '}' << '\n'

        mkdir("$generated_rsrc_dir/$packagePath")
        file("$generated_rsrc_dir/$packagePath/R.java").write(sb.toString())

        releaseRClasses += "$packagePath/R.class"
        releaseRClasses += "$packagePath/R\$*.class"
    }
}

task collectRClass << {
    delete base_r2x_dir
    mkdir base_r2x_dir

    copy {
        from classs_release_dir
        include releaseRClasses
        into base_r2x_dir
    }
}

task releaseRClass(type: org.gradle.jvm.tasks.Jar, dependsOn: collectRClass) {
    destinationDir file("$bundle_release_dir/libs/")
    from base_r2x_dir
}

task releaseJavaJars(dependsOn: releaseRClass) << {
    println "Running RELEASE-AAR Task :releaseJavaJars"

    releaseAarDirs.each { aarPath ->
        copy {
            from zipTree("$aarPath/jars/classes.jar")
            into classs_release_dir
        }

        FileTree jars = fileTree(dir: "$aarPath/jars", include: '*.jar', exclude: 'classes.jar')
        jars += fileTree(dir: "$aarPath/jars/libs", include: '*.jar')
        jars += fileTree(dir: "$aarPath/libs", include: '*.jar')

        copy {
            from jars
            into file("$bundle_release_dir/libs")
        }

        copy {
            from releaseJars
            into file("$bundle_release_dir/libs")
        }
    }
}

task releaseJniLibs << {
    println "Running RELEASE-AAR Task :releaseJniLibs"

    releaseAarDirs.each { aarPath ->
        println "======= Copying JNI from $aarPath/jni"
        copy {
            from fileTree(dir: "$aarPath/jni")
            into file("$bundle_release_dir/jni")
        }
    }
}

task releaseManifests << {
    println "Running RELEASE-AAR Task :releaseManifests"

    ILogger mLogger = new MiLogger()
    List<File> libraryManifests = new ArrayList<>()

    releaseAarDirs.each { aarPath ->
        if (!libraryManifests.contains(aarPath)) {
            libraryManifests.add(file("$aarPath/AndroidManifest.xml"))
        }
    }

    File reportFile = file("${build_dir}/releaseManifestReport.txt")

    File origManifest = file("$bundle_release_dir/AndroidManifest.xml")
    File copyManifest = file("$bundle_release_dir/AndroidManifest.orig.xml")
    File aaptManifest = file("$manifest_aaapt_dir/AndroidManifest.xml")

    copy {
        from origManifest.parentFile
        into copyManifest.parentFile
        include origManifest.name
        rename(origManifest.name, copyManifest.name)
    }

    try {
        Invoker manifestMergerInvoker = ManifestMerger2.newMerger(copyManifest, mLogger, MergeType.APPLICATION)

        manifestMergerInvoker.addLibraryManifests(libraryManifests.toArray(new File[libraryManifests.size()]))

        manifestMergerInvoker.setMergeReportFile(reportFile);

        MergingReport mergingReport = manifestMergerInvoker.merge();

        mLogger.info("Merging result:" + mergingReport.getResult());
        MergingReport.Result result = mergingReport.getResult();
        switch (result) {
            case MergingReport.Result.WARNING:
                mergingReport.log(mLogger);
            case MergingReport.Result.SUCCESS:
                XmlDocument xmlDocument = mergingReport.getMergedXmlDocument(MergingReport.MergedManifestKind.MERGED);
                try {
                    String annotatedDocument = mergingReport.getActions().blame(xmlDocument);
                    mLogger.verbose(annotatedDocument);
                } catch (Exception e) {
                    mLogger.error(e, "cannot print resulting xml");
                }
                save(xmlDocument, origManifest);
                mLogger.info("Merged manifest saved to " + origManifest);
                if (aaptManifest.exists()) {
                    new PlaceholderEncoder().visit(xmlDocument);
                    save(xmlDocument, aaptManifest);
                    mLogger.info("Merged aapt safe manifest saved to " + aaptManifest);
                }
                break;
            case MergingReport.Result.ERROR:
                mergingReport.log(mLogger);
                throw new RuntimeException(mergingReport.getReportString());
            default:
                throw new RuntimeException("Unhandled result type : " + mergingReport.getResult());
        }
    } catch (RuntimeException e) {
        e.printStackTrace()
        throw new RuntimeException(e);
    }
}

private void save(XmlDocument xmlDocument, File out) {
    try {
        Files.write(xmlDocument.prettyPrint(), out, Charsets.UTF_8);
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}

class MiLogger implements ILogger {

    @Override
    void error(
            @Nullable Throwable t,
            @Nullable String msgFormat, Object... args) {
        System.err.println(String.format("========== ERROR : " + msgFormat, args))
        if (t) t.printStackTrace(System.err)
    }

    @Override
    void warning(@NonNull String msgFormat, Object... args) {
        System.err.println(String.format("========== WARNING : " + msgFormat, args))
    }

    @Override
    void info(@NonNull String msgFormat, Object... args) {
        System.out.println(String.format("========== INFO : " + msgFormat, args))
    }

    @Override
    void verbose(@NonNull String msgFormat, Object... args) {
        // System.out.println(String.format("========== DEBUG : " + msgFormat, args))
    }
}